@startuml
!theme plain
title Class Diagram: Epoll Networking Server & Client (Hybrid Reactor + Thread Pool with PThread)
package "networking" {
class NetworkUtility {
+setNonBlocking(fd: int)
+createSocket(domain, type, protocol)
+bind(sock, addr, addrlen)
+listen(sock, backlog)
+accept(sock, addr, addrlen)
+connect(sock, addr, addrlen)
+read(fd, buf, count)
+write(fd, buf, count)
+close(fd)
}
interface IEventHandler {
+handle(fd: int, events: uint32_t)
}
class Socket {
-fd_: int
+Socket(fd: int)
+Socket(domain, type, protocol)
+~Socket()
+fd(): int
+bindAndListen(port: uint16_t, backlog)
+connectTo(host: string, port: uint16_t)
+accept(): Socket
}
class Epoll {
-epoll_fd_: int
-MAX_EVENTS: size_t
+Epoll()
+~Epoll()
+fd(): int
+add(fd: int, events: uint32_t, user_data: int)
+modify(fd: int, events: uint32_t)
+remove(fd: int)
+wait(events: vector<epoll_event>, timeout: int): size_t
}
' Task & Processing
class Task {
type: TaskType
fd: int
data: variant<monostate, string, vector<char>>
+Task(type: TaskType, fd: int)
+Task(type: TaskType, fd: int, msg: string)
+Task(type: TaskType, fd: int, buf: vector<char>)
}
enum TaskType {
ProcessRecv
Broadcast
SendSpecific
Cleanup
}
interface ITaskProcessor {
+process(task: Task)
}
class DefaultTaskProcessor {
-clients: unordered_map<int, string>&
-client_mutex: shared_mutex
+process(task: Task)
}
class PThread {
-thread_: pthread_t
-func_: function<void()>
-joined_: bool
+PThread(func: function<void()>)
+~PThread()
+join()
+native(): pthread_t
}
class ThreadPool {
-workers_: vector<PThread>
-task_queue_: queue<Task>
-queue_mutex_: mutex
-cv_: condition_variable
-processor_: unique_ptr<ITaskProcessor>
-stop_: bool
-num_threads_: size_t
+ThreadPool(num_threads: size_t, proc: unique_ptr<ITaskProcessor>)
+~ThreadPool()
+enqueue(task: Task)
-workerLoop()
}
' Server Classes (Updated)
class ServerHandler {
-epoll_: Epoll&
-pool_: ThreadPool&
-clients: unordered_map<int, string>&
-client_mutex: shared_mutex
-server_fd_: int
+handle(fd: int, events: uint32_t)
}
class ClientHandler {
-pool_: ThreadPool&
+handle(fd: int, events: uint32_t)
}
class ServerStdinHandler {
-pool_: ThreadPool&
-clients: unordered_map<int, string>&
-client_mutex: shared_mutex
+handle(fd: int, events: uint32_t)
}
class EpollServer {
-server_socket_: Socket
-epoll_: Epoll
-client_handlers_: unordered_map<int, unique_ptr<IEventHandler>>
-server_handler_: unique_ptr<IEventHandler>
-stdin_handler_: unique_ptr<IEventHandler>
-pool_: ThreadPool
-client_map_: unordered_map<int, string>
+EpollServer()
+run()
-cleanupIoFd(fd: int)
}
' Client Classes (Unchanged for simplicity)
class ClientSocketHandler {
+handle(fd: int, events: uint32_t)
}
class ClientStdinHandler {
-socket_fd_: int
+handle(fd: int, events: uint32_t)
}
class EpollClient {
-socket_: Socket
-epoll_: Epoll
-socket_handler_: unique_ptr<IEventHandler>
-stdin_handler_: unique_ptr<IEventHandler>
+EpollClient(host: string, port: uint16_t)
+run()
}
' Relationships
Socket ..> NetworkUtility : uses
Epoll ..> NetworkUtility : uses
IEventHandler <|.. ServerHandler
IEventHandler <|.. ClientHandler
IEventHandler <|.. ServerStdinHandler
IEventHandler <|.. ClientSocketHandler
IEventHandler <|.. ClientStdinHandler
TaskType .. Task : enum
ITaskProcessor <|.. DefaultTaskProcessor
ThreadPool *-- ITaskProcessor : uses (processor_)
ThreadPool ..> Task : enqueues
ThreadPool *-- PThread : composes (workers_)
DefaultTaskProcessor ..> Task : processes
ServerHandler ..> Epoll : depends
ServerHandler ..> ThreadPool : depends
ServerHandler ..> DefaultTaskProcessor : accesses (clients)
ClientHandler ..> ThreadPool : enqueues
ServerStdinHandler ..> ThreadPool : enqueues
ServerStdinHandler ..> DefaultTaskProcessor : accesses (clients)
EpollServer *-- Socket : composes
EpollServer *-- Epoll : composes
EpollServer *-- ThreadPool : composes
EpollServer o-- IEventHandler : uses (server_handler_, stdin_handler_)
EpollServer *-- unordered_map : has (client_handlers_, client_map_)
EpollClient *-- Socket : composes
EpollClient *-- Epoll : composes
EpollClient o-- IEventHandler : uses (socket_handler_, stdin_handler_)
ClientStdinHandler ..> NetworkUtility : uses (write)
ClientSocketHandler ..> NetworkUtility : uses (read, write)
}
note top of EpollServer : Reactor: I/O only (epoll loop)\nComposes ThreadPool (PThread-based) for processing\nHandles broadcast/specific via queued tasks
note top of ThreadPool : Producer-Consumer: Main enqueues, workers dequeue/process\nDI: Injects ITaskProcessor (Strategy)\nUses PThread RAII for auto-join
note top of PThread : Wrapper for pthread: RAII join/dtor\nMove-only, exception-safe
note top of DefaultTaskProcessor : Business logic (echo, broadcast)\nThread-safe shared state (shared_mutex)
note top of EpollClient : Unchanged (single-thread client)
@enduml